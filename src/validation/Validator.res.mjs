// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core__Int from "@rescript/core/src/Core__Int.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";

function requiredFields(itemType) {
  switch (itemType) {
    case "Book" :
        return [
                "title",
                "creators",
                "publisher",
                "date"
              ];
    case "BookSection" :
    case "JournalArticle" :
        return [
                "title",
                "creators",
                "publicationTitle",
                "date"
              ];
    case "Webpage" :
        return [
                "title",
                "url",
                "date"
              ];
    case "Manuscript" :
        return [
                "title",
                "creators"
              ];
    case "ConferencePaper" :
    case "Thesis" :
    case "Report" :
    case "Patent" :
        return [
                "title",
                "creators",
                "date"
              ];
    
  }
}

function hasField(citation, field) {
  switch (field) {
    case "creators" :
        return citation.creators.length > 0;
    case "date" :
        return Core__Option.isSome(citation.date);
    case "publicationTitle" :
        return Core__Option.isSome(citation.publicationTitle);
    case "publisher" :
        return Core__Option.isSome(citation.publisher);
    case "title" :
        return citation.title.length > 0;
    case "url" :
        return Core__Option.isSome(citation.url);
    default:
      return false;
  }
}

function validateStructure(citation) {
  var issues = [];
  var required = requiredFields(citation.itemType);
  var missingFields = required.filter(function (field) {
        return !hasField(citation, field);
      });
  var fieldIssues = missingFields.map(function (field) {
        return {
                severity: "SeverityError",
                field: field,
                message: "Required field \"" + field + "\" is missing",
                suggestion: "Add " + field + " to complete citation structure",
                requiresUncertaintyNavigation: false
              };
      });
  var creatorIssues = citation.creators.length === 0 ? [{
        severity: "SeverityError",
        field: "creators",
        message: "Citation must have at least one creator",
        suggestion: "Add author, editor, or contributor",
        requiresUncertaintyNavigation: false
      }] : [];
  var titleIssues = citation.title.trim().length === 0 ? [{
        severity: "SeverityError",
        field: "title",
        message: "Title cannot be empty",
        suggestion: "Add a title for this citation",
        requiresUncertaintyNavigation: false
      }] : [];
  return issues.concat(fieldIssues).concat(creatorIssues).concat(titleIssues);
}

function isValidDateFormat(date) {
  var datePattern = /^\d{4}(-\d{2}(-\d{2})?)?$/;
  return datePattern.test(date);
}

function extractYear(date) {
  if (date.length >= 4) {
    return Core__Int.fromString(date.substring(0, 4), undefined);
  }
  
}

function validateConsistency(citation) {
  var issues = [];
  var date = citation.date;
  var dateIssues;
  if (date !== undefined) {
    if (isValidDateFormat(date)) {
      var year = extractYear(date);
      dateIssues = year !== undefined ? (
          year < 1000 || year > 2100 ? [{
                severity: "SeverityWarning",
                field: "date",
                message: "Unusual publication year: " + year.toString(),
                suggestion: "Verify publication date is correct",
                requiresUncertaintyNavigation: true
              }] : []
        ) : [];
    } else {
      dateIssues = [{
          severity: "SeverityError",
          field: "date",
          message: "Invalid date format: \"" + date + "\"",
          suggestion: "Use ISO 8601 format (YYYY, YYYY-MM, or YYYY-MM-DD)",
          requiresUncertaintyNavigation: false
        }];
    }
  } else {
    dateIssues = [];
  }
  var creatorIssues = citation.creators.filter(function (c) {
          return c.lastName.trim().length === 0;
        }).map(function (param) {
        return {
                severity: "SeverityError",
                field: "creators",
                message: "Creator missing lastName",
                suggestion: "Add lastName for all creators",
                requiresUncertaintyNavigation: false
              };
      });
  return issues.concat(dateIssues).concat(creatorIssues);
}

function isValidDOI(doi) {
  var doiPattern = /^10\.\d{4,}\/\S+$/;
  return doiPattern.test(doi);
}

function isValidISBN(isbn) {
  var clean = isbn.replace(/[-\s]/g, "");
  if (clean.length === 10) {
    return true;
  } else {
    return clean.length === 13;
  }
}

function validateReferences(citation) {
  var issues = [];
  var doi = citation.doi;
  var doiIssues = doi !== undefined ? (
      isValidDOI(doi) ? [] : [{
            severity: "SeverityWarning",
            field: "DOI",
            message: "DOI format may be invalid",
            suggestion: "DOI should start with \"10.\" followed by registrant/suffix",
            requiresUncertaintyNavigation: false
          }]
    ) : [];
  var isbn = citation.isbn;
  var isbnIssues = isbn !== undefined ? (
      isValidISBN(isbn) ? [] : [{
            severity: "SeverityWarning",
            field: "ISBN",
            message: "ISBN should be 10 or 13 digits",
            suggestion: "Verify ISBN is correct",
            requiresUncertaintyNavigation: false
          }]
    ) : [];
  var identifierIssues = Core__Option.isNone(citation.doi) && Core__Option.isNone(citation.isbn) && Core__Option.isNone(citation.url) && citation.itemType !== "Manuscript" ? [{
        severity: "SeverityWarning",
        field: "identifiers",
        message: "No persistent identifier (DOI, ISBN, or URL)",
        suggestion: "Add DOI or ISBN if available",
        requiresUncertaintyNavigation: true
      }] : [];
  return issues.concat(doiIssues).concat(isbnIssues).concat(identifierIssues);
}

function determineState(issues) {
  var errors = issues.filter(function (i) {
        return i.severity === "SeverityError";
      });
  var uncertainties = issues.filter(function (i) {
        return i.requiresUncertaintyNavigation;
      });
  if (errors.length <= 0) {
    if (uncertainties.length > 0) {
      return "Uncertain";
    } else {
      return "Valid";
    }
  }
  var hasConsistencyErrors = errors.some(function (e) {
        if (e.message.includes("Invalid")) {
          return true;
        } else {
          return e.message.includes("inconsistent");
        }
      });
  if (hasConsistencyErrors) {
    return "Inconsistent";
  } else {
    return "Incomplete";
  }
}

function generateCertaintyReasoning(structural, consistency, referential, issues) {
  var structuralPart = structural >= 0.9 ? "Structurally complete" : (
      structural >= 0.7 ? "Mostly complete structure" : "Missing required fields"
    );
  var consistencyPart = consistency >= 0.9 ? "internally consistent" : (
      consistency >= 0.7 ? "minor inconsistencies" : "significant inconsistencies"
    );
  var referentialPart = referential >= 0.8 ? "strong referential integrity" : (
      referential >= 0.5 ? "some referential identifiers" : "weak referential integrity"
    );
  var uncertaintyCount = issues.filter(function (i) {
        return i.requiresUncertaintyNavigation;
      }).length;
  var uncertaintyPart = uncertaintyCount > 0 ? ", " + uncertaintyCount.toString() + " uncertainties require Fogbinder exploration" : "";
  return structuralPart + ", " + consistencyPart + ", " + referentialPart + uncertaintyPart + ".";
}

function calculateCertainty(citation, issues) {
  var required = requiredFields(citation.itemType);
  var presentCount = required.filter(function (field) {
        return hasField(citation, field);
      }).length;
  var structural = required.length > 0 ? presentCount / required.length : 1.0;
  var errors = issues.filter(function (i) {
        return i.severity === "SeverityError";
      });
  var totalChecks = issues.length + 10 | 0;
  var consistency = 1.0 - errors.length / totalChecks;
  var doiBoost = Core__Option.isSome(citation.doi) ? 0.3 : 0.0;
  var isbnBoost = Core__Option.isSome(citation.isbn) ? 0.2 : 0.0;
  var urlBoost = Core__Option.isSome(citation.url) ? 0.1 : 0.0;
  var total = 0.5 + doiBoost + isbnBoost + urlBoost;
  var referential = total > 1.0 ? 1.0 : total;
  var score = structural * 0.5 + consistency * 0.3 + referential * 0.2;
  var reasoning = generateCertaintyReasoning(structural, consistency, referential, issues);
  return {
          score: Math.round(score * 100.0) / 100.0,
          factors: {
            structural: Math.round(structural * 100.0) / 100.0,
            consistency: Math.round(consistency * 100.0) / 100.0,
            referential: Math.round(referential * 100.0) / 100.0
          },
          reasoning: reasoning
        };
}

function validate(citation) {
  var structuralIssues = validateStructure(citation);
  var consistencyIssues = validateConsistency(citation);
  var referentialIssues = validateReferences(citation);
  var issues = structuralIssues.concat(consistencyIssues).concat(referentialIssues);
  var state = determineState(issues);
  var certainty = calculateCertainty(citation, issues);
  return {
          citation: citation,
          state: state,
          certainty: certainty,
          issues: issues,
          timestamp: new Date()
        };
}

function validateBatch(citations) {
  return citations.map(validate);
}

export {
  requiredFields ,
  hasField ,
  validateStructure ,
  isValidDateFormat ,
  extractYear ,
  validateConsistency ,
  isValidDOI ,
  isValidISBN ,
  validateReferences ,
  determineState ,
  calculateCertainty ,
  generateCertaintyReasoning ,
  validate ,
  validateBatch ,
}
/* No side effect */
